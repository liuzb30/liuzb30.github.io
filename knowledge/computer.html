<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>三、计算机基础 | 刘圳槟的个人博客</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/logo.jpg">
    <meta name="description" content="刘圳槟的个人博客">
    
    <link rel="preload" href="/assets/css/0.styles.22323a62.css" as="style"><link rel="preload" href="/assets/js/app.9dcc8cee.js" as="script"><link rel="preload" href="/assets/js/2.b5a88b1a.js" as="script"><link rel="preload" href="/assets/js/10.7b0a7f5b.js" as="script"><link rel="prefetch" href="/assets/js/11.d018335d.js"><link rel="prefetch" href="/assets/js/12.64368439.js"><link rel="prefetch" href="/assets/js/3.da5547c3.js"><link rel="prefetch" href="/assets/js/4.d159f790.js"><link rel="prefetch" href="/assets/js/5.fb70b555.js"><link rel="prefetch" href="/assets/js/6.fbbd1b54.js"><link rel="prefetch" href="/assets/js/7.ac97d0a7.js"><link rel="prefetch" href="/assets/js/8.5277a6ce.js"><link rel="prefetch" href="/assets/js/9.ff65d08b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.22323a62.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">刘圳槟的个人博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/knowledge/css.html" class="nav-link">
  前端知识体系
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/knowledge/css.html" class="nav-link">
  前端知识体系
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>前端知识体系</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/knowledge/javascript.html" class="sidebar-link">JavaScript</a></li><li><a href="/knowledge/css.html" class="sidebar-link">HTML和CSS</a></li><li><a href="/knowledge/computer.html" aria-current="page" class="active sidebar-link">计算机基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/knowledge/computer.html#编译原理" class="sidebar-link">编译原理</a></li><li class="sidebar-sub-header"><a href="/knowledge/computer.html#网络协议" class="sidebar-link">网络协议</a></li><li class="sidebar-sub-header"><a href="/knowledge/computer.html#设计模式" class="sidebar-link">设计模式</a></li></ul></li><li><a href="/knowledge/algorithms.html" class="sidebar-link">算法</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="三、计算机基础"><a href="#三、计算机基础" class="header-anchor">#</a> 三、计算机基础</h1> <blockquote><p>关于编译原理，不需要理解非常深入，但是最基本的原理和概念一定要懂，这对于学习一门编程语言非常重要</p></blockquote> <h2 id="编译原理"><a href="#编译原理" class="header-anchor">#</a> 编译原理</h2> <h4 id="_1-理解代码到底是什么-计算机如何将代码转换为可以运行的目标程序"><a href="#_1-理解代码到底是什么-计算机如何将代码转换为可以运行的目标程序" class="header-anchor">#</a> 1.理解代码到底是什么，计算机如何将代码转换为可以运行的目标程序</h4> <p>代码就是我们写出来的源文件。</p> <p>计算机将我们写的代码翻译成计算机可执行的二进制指令，这个过程叫编译。</p> <h4 id="_2-正则表达式的匹配原理和性能优化"><a href="#_2-正则表达式的匹配原理和性能优化" class="header-anchor">#</a> 2.正则表达式的匹配原理和性能优化</h4> <h4 id="_3-如何将-javascript-代码解析成抽象语法树-ast"><a href="#_3-如何将-javascript-代码解析成抽象语法树-ast" class="header-anchor">#</a> 3.如何将 JavaScript 代码解析成抽象语法树(AST)</h4> <h4 id="_4-base64-的编码原理"><a href="#_4-base64-的编码原理" class="header-anchor">#</a> 4.base64 的编码原理</h4> <h4 id="_5-几种进制的相互转换计算方法-在-javascript-中如何表示和转换"><a href="#_5-几种进制的相互转换计算方法-在-javascript-中如何表示和转换" class="header-anchor">#</a> 5.几种进制的相互转换计算方法，在 JavaScript 中如何表示和转换</h4> <p><code>parseInt(str, radix)</code> 将一个 radix 进制的 str 转化为十进制，<code>parseInt('23',8) // 19</code>，将八进制的‘23’转化为 10 进制的‘19’</p> <p><code>number.toString(radix)</code> 将一个数字转化为 radix 进制的数字字符串</p> <h2 id="网络协议"><a href="#网络协议" class="header-anchor">#</a> 网络协议</h2> <h4 id="_1-理解什么是协议-了解-tcp-ip-网络协议族的构成-每层协议在应用程序中发挥的作用"><a href="#_1-理解什么是协议-了解-tcp-ip-网络协议族的构成-每层协议在应用程序中发挥的作用" class="header-anchor">#</a> 1.理解什么是协议，了解 TCP/IP 网络协议族的构成，每层协议在应用程序中发挥的作用</h4> <h4 id="_2-三次握手和四次挥手详细原理-为什么要使用这种机制"><a href="#_2-三次握手和四次挥手详细原理-为什么要使用这种机制" class="header-anchor">#</a> 2.三次握手和四次挥手详细原理，为什么要使用这种机制</h4> <ul><li><p>三次握手</p> <p>三次握手，是指建立一个 TCP 连接时，需要客户端和服务端总共发送三个报文。</p> <p>第一次握手：客户端请求建立连接，发送标志位 SYN 和序列号 seq=J 给服务端。（客户端进入 SYN_SENT 状态）</p> <p>第二次握手：服务端收到数据包后，由标志位 SYN=1 知道客户端请求建立连接，服务端将标志位 SYN 和 ACK 置为 1，ack=seq+1，并随机生成一个 seq=K,将该数据包发给客户端以确认连接请求（服务端进入 SYN_RCVD 状态）</p> <p>第三次握手：客户端收到确认后，检查数据是否正确，正确则向服务端发送确认信息，所以需要发送标志位 ACK 和确认号 ack。ack = K+ 1。服务端也检查数据是否正确，正确则连接建立成功。</p></li> <li><p>四次握手</p> <p>四次挥手，是指断开一个 TCP 连接时，需要客户端和服务端总共发送 4 个包已确认连接的断开。</p> <p>第一次挥手：客户端发起断开连接请求，向服务端发送标志位 FIN,设置序列号 seq=j。</p> <p>第二次挥手：服务端收到客户端的断开请求，向客户端发送标志位 ACK,确认号 ack=j+1，表示同意断开连接请求。</p> <p>第三次挥手：服务端向客户端发送标志位 FIN，设置序列号 seq=k，请求关闭连接。</p> <p>第四次挥手：客户端收到服务端的 FIN 报文，向服务端发送 ACK 的报文段，然后客户端进入 TIME_WAIT 状态。服务端收到客户端的确认报文后，就关闭连接。此时，客户端等待 2MSL 的时间后依然没有收到回复，则证明服务端已经断开连接。</p></li> <li><p>为什么需要三次握手？</p> <p>三次握手是为了避免服务端的资源浪费。假设客户端发了一个请求，由于网络的原因，很久才被服务端收到，服务端以为这是一个实时请求，就跟客户端建立了连接。由于客户端并没有建立连接的请求，就不理睬服务端。但服务端以为连接已经建立，就一直在等待客户端发来数据。这样，服务端的很多资源就白白浪费了。</p> <p>TCP 三次握手跟现实生活中的人与人打电话是很类似的</p></li> <li><p>为什么连接的时候是三次握手，关闭的时候却是四次握手？</p> <p>因为建立连接时，服务端收到客户端的请求后，可以直接发送 SYN 和 ACK 报文，所以只需要三次握手。</p> <p>而关闭连接时，当客户端发出 FIN 报文时，只是表示客户端不再像服务端发送数据了。所以当服务端收到客户端的断开请求时，向客户端发送 ACK 报文表示已经知道。但是服务端还是可以继续给客户端发送数据（TCP 是全双工模式），所以不会马上关闭 socket，直到服务端数据发送完毕，向客户端发送 FIN 报文时，这个时候服务端也没有数据要发送了，这个时候两边才断开连接。</p></li> <li><p>为什么要等待 2MSL？</p> <p><strong>MSL</strong>：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。</p> <p><strong>第一点：保证 TCP 协议的全双工连接能够可靠关闭</strong>：</p> <p>为了保证服务端能够收到 ACK 报文</p> <p><strong>第二点：保证这次连接的重复数据段从网络中消失</strong></p></li></ul> <p><a href="https://blog.csdn.net/a519640026/article/details/104448480/" target="_blank" rel="noopener noreferrer">一文彻底搞懂 TCP 三次握手和四次挥手<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h4 id="_3-有哪些协议是可靠-tcp-有哪些手段保证可靠交付"><a href="#_3-有哪些协议是可靠-tcp-有哪些手段保证可靠交付" class="header-anchor">#</a> 3.有哪些协议是可靠，TCP 有哪些手段保证可靠交付</h4> <p>TCP 的协议：FTP(文件传输协议)、Telnet（远程登录协议）、SMTP、POP3（邮件传输协议）、HTTP 协议等。</p> <p>三次握手和四次挥手</p> <h4 id="_4-dns-的作用、dns-解析的详细过程-dns-优化原理"><a href="#_4-dns-的作用、dns-解析的详细过程-dns-优化原理" class="header-anchor">#</a> 4.DNS 的作用、DNS 解析的详细过程，DNS 优化原理</h4> <p><strong>DNS 的作用</strong>：它是互联网的一项服务，是一个将域名和 IP 地址互相映射的分布式数据库，能够使人更为方便地访问互联网。</p> <p><strong>DNS 解析过程</strong>：本地 hosts 文件 -&gt; 本地 DNS 解析器缓存 -&gt; 本地 DNS 服务器 -&gt; 上一级 DNS 服务器(转发模式) -&gt; 13 台根 DNS(非转发模式) -&gt; 顶级域名服务器 -&gt;下一级域名服务器（直到找到为止）。</p> <p><strong>DNS 优化</strong>：</p> <ul><li>减少 DNS 的请求次数；（项目中减少不同域名的 http 请求）</li> <li>进行 DNS 预获取 。（减少用户的等待时间，提升用户体验 。）</li></ul> <p>默认情况下浏览器会对页面中和当前域名（正在浏览网页的域名）不在同一个域的域名进行预获取，并且缓存结果，这就是隐式的 DNS Prefetch。如果想对页面中没有出现的域进行预获取，那么就要使用显示的 DNS Prefetch 了。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>x-dns-prefetch-control<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>on<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>dns-prefetch<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>//www.itechzero.com<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>dns-prefetch<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>//api.share.baidu.com<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>dns-prefetch<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>//bdimg.share.baidu.com<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div><h4 id="_5-cdn-的作用和原理"><a href="#_5-cdn-的作用和原理" class="header-anchor">#</a> 5.CDN 的作用和原理</h4> <p><a href="https://www.wc1234.cn/2046.html" target="_blank" rel="noopener noreferrer">简单地聊聊 CDN 原理作用及实现方法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h4 id="_6-http-请求报文和响应报文的具体组成-能理解常见请求头的含义-有几种请求方式-区别是什么"><a href="#_6-http-请求报文和响应报文的具体组成-能理解常见请求头的含义-有几种请求方式-区别是什么" class="header-anchor">#</a> 6.HTTP 请求报文和响应报文的具体组成，能理解常见请求头的含义，有几种请求方式，区别是什么</h4> <h4 id="_7-http-所有状态码的具体含义-看到异常状态码能快速定位问题"><a href="#_7-http-所有状态码的具体含义-看到异常状态码能快速定位问题" class="header-anchor">#</a> 7.HTTP 所有状态码的具体含义，看到异常状态码能快速定位问题</h4> <ul><li><strong>1XX：信息状态码</strong></li> <li><strong>2XX：成功状态码</strong> <ul><li>200: 正常返回</li> <li>201：Created 请求成功并且服务器创建了新的资源</li> <li>202：Accepted 服务器接受请求但未处理</li></ul></li> <li><strong>3XX：重定向</strong> <ul><li>301：Moved Permanently 永久重定向</li> <li>302：Found 临时性重定向</li> <li>303：See Other 临时性重定向，且总是使用 GET 请求新的 URI。</li> <li>304：Not Modified 资源未过期</li></ul></li> <li><strong>4XX：客户端错误</strong> <ul><li>400 Bad Request 服务器无法理解请求的格式</li> <li>401 Unauthorized 请求未授权</li> <li>403 Forbidden 禁止访问</li> <li>404 Not found 找不到对应的资源</li></ul></li> <li><strong>5XX: 服务器错误</strong> <ul><li>500 Internal Server Error 最常见的服务器端错误。</li> <li>503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</li></ul></li></ul> <h4 id="_8-http1-1、http2-0-带来的改变"><a href="#_8-http1-1、http2-0-带来的改变" class="header-anchor">#</a> 8.HTTP1.1、HTTP2.0 带来的改变</h4> <h4 id="http1-1"><a href="#http1-1" class="header-anchor">#</a> HTTP1.1</h4> <ul><li><p>缓存处理</p> <ul><li>在 <code>HTTP1.0</code> 中主要使用 <code>header</code> 里的 <code>If-Modified-Since,Expires</code> 来做为缓存判断的标准</li> <li><code>HTTP1.1</code> 则引入了更多的缓存控制策略例如 <code>Entity tag，If-Unmodified-Since, If-Match, If-None-Match</code> 等更多可供选择的缓存头来控制缓存策略。</li></ul></li> <li><p>带宽优化及网络连接的使用</p> <p><code>HTTP1.0</code> 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，<code>HTTP1.1</code> 则在请求头引入了 <code>range</code> 头域，它允许只请求资源的某个部分，即返回码是 <code>206（Partial Content）</code>，这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p></li> <li><p>错误通知的管理</p> <p>在 <code>HTTP1.1</code> 中新增了<code>24</code> 个错误状态响应码，如 <code>409（Conflict）</code>表示请求的资源与资源的当前状态发生冲突；<code>410（Gone）</code>表示服务器上的某个资源被永久性的删除。</p></li> <li><p>Host 头处理</p> <p>在 <code>HTTP1.0</code> 中认为每台服务器都绑定一个唯一的 <code>IP</code> 地址，因此，请求消息中的 <code>URL</code> 并没有传递主机名 <code>（hostname）</code>。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机<code>（Multi-homed Web Servers）</code>，并且它们共享一个 <code>IP</code> 地址。<code>HTTP1.1</code> 的请求消息和响应消息都应支持 <code>Host</code> 头域，且请求消息中如果没有 <code>Host</code> 头域会报告一个错误<code>（400 Bad Request）</code>。</p></li> <li><p>长连接</p> <p><code>HTTP 1.1</code> 支持长连接<code>（PersistentConnection）</code>和请求的流水线<code>（Pipelining）</code>处理，在一个 <code>TCP</code> 连接上可以传送多个 <code>HTTP</code> 请求和响应，减少了建立和关闭连接的消耗和延迟，在 <code>HTTP1.1</code> 中默认开启 <code>Connection： keep-alive</code>，一定程度上弥补了 <code>HTTP1.0</code> 每次请求都要创建连接的缺点。</p></li></ul> <h4 id="http2-0"><a href="#http2-0" class="header-anchor">#</a> HTTP2.0</h4> <ul><li><p>二进制格式</p> <p><code>HTTP1.x</code> 的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认 <code>0</code> 和 <code>1</code> 的组合。基于这种考虑 <code>HTTP2.0</code> 的协议解析决定采用二进制格式，实现方便且健壮。</p></li> <li><p>多路复用</p> <p>即连接共享，即每一个 <code>request</code> 都是是用作连接共享机制的。一个 <code>request</code> 对应一个 <code>id</code>，这样一个连接上可以有多个 <code>request</code>，每个连接的 <code>request</code> 可以随机的混杂在一起，接收方可以根据 <code>request</code> 的 <code>id</code> 将 <code>request</code> 再归属到各自不同的服务端请求里面。</p></li> <li><p>头部压缩</p> <p><code>HTTP1.x</code> 的 <code>header</code> 带有大量信息，而且每次都要重复发送，<code>HTTP2.0</code> 使用 <code>encoder</code> 来减少需要传输的 <code>header</code> 大小，通讯双方各自 <code>cache</code> 一份 <code>header fields</code> 表，既避免了重复 <code>header</code> 的传输，又减小了需要传输的大小。</p></li> <li><p>服务端推送</p> <p><code>HTTP2.0</code>具有 <code>server push</code> 功能。</p></li></ul> <h4 id="_9-https-的加密原理-如何开启-https-如何劫持-https-请求"><a href="#_9-https-的加密原理-如何开启-https-如何劫持-https-请求" class="header-anchor">#</a> 9.HTTPS 的加密原理，如何开启 HTTPS，如何劫持 HTTPS 请求</h4> <p>加密原理：</p> <ul><li>浏览器发出请求</li> <li>服务器发送数字证书（包含服务器的公钥）</li> <li>浏览器用预置的 CA 列表验证证书，如果有问题，则提示风险</li> <li>浏览器生产随机的对称密钥，用服务器的公钥加密</li> <li>服务器用自己的私钥解密，得到对称密钥</li> <li>双方都知道了对称密钥，用它来加密通信</li></ul> <p>重点：</p> <p>为了保证浏览器能安全把对称密钥传给服务器，双方用对称密钥来通讯。需要对对称密钥进行加密，就得服务器把公钥发送给浏览器；而服务器为了能安全发送公钥，就得用数字证书来加密。</p> <ul><li>为了对数据进行加密传输，引入了对称加密（密钥如何传输）</li> <li>为了解决密钥传输问题，引入了非对称加密 RSA（加解密速度慢）</li> <li>为了解决速度慢的问题，想出了非对称加密+对称加密（有可能遇到中间人攻击）</li> <li>为了解决公钥的正确性，引入了数字签名和认证中心 CA(浏览器会内置顶层的 CA 证书)
<ul><li>对公钥和个人信息进行 hash 得到消息摘要，然后用 CA 的私钥对摘要加密</li> <li>浏览器对公钥和个人信息进行 hash 得到消息摘要，然后用 CA 的公钥进行解密，对消息摘要进行比对。</li></ul></li></ul> <p>参考文章：<a href="https://mp.weixin.qq.com/s/StqqafHePlBkWAPQZg3NrA" target="_blank" rel="noopener noreferrer">【一个故事讲完 https】<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h4 id="_10-理解-websocket-协议的底层原理、与-http-的区别"><a href="#_10-理解-websocket-协议的底层原理、与-http-的区别" class="header-anchor">#</a> 10.理解 WebSocket 协议的底层原理、与 HTTP 的区别</h4> <p>WebSocket 是基于 HTTP 协议的，或者说借用了 HTTP 协议来完成一部分握手。握手成功后就建立了 websocket 连接，然后服务端就可以向客户端推送消息了。</p> <p>ajax 轮询 ：每隔几秒像服务器发送请求，询问是否有新消息。（需要服务端有很快的处理速度和资源）</p> <p>long poll：原理和 ajax 差不多，不过采用的的阻塞模型，也就是发起连接后，保持连接，直到服务器返回消息，返回后，客户端再重新发起消息，周而复始。（需要服务端有很高的并发）</p> <p>参考文章：<a href="https://blog.csdn.net/jing_80/article/details/82111423" target="_blank" rel="noopener noreferrer">看完让你理解 WebSocket 原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="设计模式"><a href="#设计模式" class="header-anchor">#</a> 设计模式</h2> <h4 id="_1-熟练使用前端常用的设计模式编写代码-如单例模式、装饰器模式、代理模式等"><a href="#_1-熟练使用前端常用的设计模式编写代码-如单例模式、装饰器模式、代理模式等" class="header-anchor">#</a> 1.熟练使用前端常用的设计模式编写代码，如单例模式、装饰器模式、代理模式等</h4> <p>代理模式分为：保护代理和虚拟代理</p> <p>单例模式：全局只有一个实例</p> <p>策略模式：有两个部分，策略类和环境类。策略类封装了具体的算法，环境类接受用户的请求，并把请求委托给策略类。</p> <p>装饰器模式：在不改变原有功能的基础上增加新的功能。</p> <p>参考文章：<a href="https://zxpsuper.github.io/Demo/advanced_front_end/js/design.html#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener noreferrer">【设计模式】<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://segmentfault.com/a/1190000017743794" target="_blank" rel="noopener noreferrer">js 设计模式--代理模式<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h4 id="_2-发布订阅模式和观察者模式的异同以及实际应用"><a href="#_2-发布订阅模式和观察者模式的异同以及实际应用" class="header-anchor">#</a> 2.发布订阅模式和观察者模式的异同以及实际应用</h4> <h4 id="_3-可以说出几种设计模式在开发中的实际应用-理解框架源码中对设计模式的应用"><a href="#_3-可以说出几种设计模式在开发中的实际应用-理解框架源码中对设计模式的应用" class="header-anchor">#</a> 3.可以说出几种设计模式在开发中的实际应用，理解框架源码中对设计模式的应用</h4></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/knowledge/css.html" class="prev">
        HTML和CSS
      </a></span> <span class="next"><a href="/knowledge/algorithms.html">
        算法
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.9dcc8cee.js" defer></script><script src="/assets/js/2.b5a88b1a.js" defer></script><script src="/assets/js/10.7b0a7f5b.js" defer></script>
  </body>
</html>
